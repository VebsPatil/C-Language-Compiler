from __future__ import annotations

from typing import List

from .ast_nodes import Program, Function, Stmt, VarDecl, Assign, Return, ExprStmt, Expr, Number, Name, Binary, Call, String


class CodeGen:
	def __init__(self) -> None:
		self.lines: List[str] = []
		self.indent = "\t"

	def generate(self, program: Program) -> str:
		self.lines = ["# Generated by minicc (educational)"]
		for fn in program.functions:
			self._emit_function(fn)
		# Auto-run main if present
		if any(fn.name == "main" for fn in program.functions):
			self.lines.append("if __name__ == \"__main__\":")
			self.lines.append(f"{self.indent}main()")
		return "\n".join(self.lines) + "\n"

	def _emit_function(self, fn: Function) -> None:
		self.lines.append(f"def {fn.name}():")
		for stmt in fn.body:
			self._emit_stmt(stmt, level=1)
		# Ensure function ends with return if not present
		self.lines.append("")

	def _emit_stmt(self, stmt: Stmt, level: int) -> None:
		pad = self.indent * level
		if isinstance(stmt, VarDecl):
			if stmt.init is None:
				self.lines.append(f"{pad}{stmt.name} = 0")
			else:
				self.lines.append(f"{pad}{stmt.name} = {self._emit_expr(stmt.init)}")
			return
		if isinstance(stmt, Assign):
			self.lines.append(f"{pad}{stmt.name} = {self._emit_expr(stmt.value)}")
			return
		if isinstance(stmt, Return):
			if stmt.value is None:
				self.lines.append(f"{pad}return 0")
			else:
				self.lines.append(f"{pad}return {self._emit_expr(stmt.value)}")
			return
		if isinstance(stmt, ExprStmt):
			self.lines.append(f"{pad}{self._emit_expr(stmt.expr)}")
			return
		raise RuntimeError("unknown statement type")

	def _emit_expr(self, expr: Expr) -> str:
		if isinstance(expr, Number):
			return str(expr.value)
		if isinstance(expr, String):
			# repr will add quotes and proper escapes
			return repr(expr.value)
		if isinstance(expr, Name):
			return expr.ident
		if isinstance(expr, Binary):
			left = self._emit_expr(expr.left)
			right = self._emit_expr(expr.right)
			return f"({left} {expr.op} {right})"
		if isinstance(expr, Call):
			# Map printf to print; otherwise call function as-is
			fn_name = "print" if expr.func == "printf" else expr.func
			args = ", ".join(self._emit_expr(a) for a in expr.args)
			return f"{fn_name}({args})"
		raise RuntimeError("unknown expression type")


